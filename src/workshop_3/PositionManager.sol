// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity ^0.8.19;

import "evc-playground/vaults/VaultRegularBorrowable.sol";
import "evc/interfaces/IEthereumVaultConnector.sol";
import "solmate/auth/Owned.sol";
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

///////////////////////////SUMMARY///////////////////////////////////abi


contract PositionManager is Owned {
    //TYPES
    IEVC internal evc;

    //ERROR
    error vaultArrayEmpty();
    error zero_Address();
    error not_Compatible_WithVaultRegularBorrowable();
    error not_Registered();
    error not_theTime();

    //STORAGE VARIABLE
    uint internal lastBlockTimeStamp;
    //you can register your account on any of PositionManager instance on the blockchain by
    //picking your choice of rebalanceTimer.
    uint public immutable rebalanceTimer;

    //an operator can manage different account owners
    // ADDRESS OPERATOR => ADDRESS ACCOUNT => ADDRESS[] VAULTS
    mapping(address => mapping(address => address[])) internal Manager;
    address Owner;

    ////////////////////CHAINLINK AUTOMATION///////////////////////////////

    constructor(uint _rebalanceTimer) Owned(msg.sender) {
        lastBlockTimeStamp = block.timestamp;
        rebalanceTimer = _rebalanceTimer;
        Owner = msg.sender;
    }

    function registerOperatorAndVaults(
        address operator,
        address[] memory vaults
    ) external onlyOwner {
        //SANITY CHECKS
        /**
         * 1. Vault Array must not be empty
         * 2. Operator must not be zero address
         */
        if (operator == address(0)) {
            revert zero_Address();
        }
        if (vaults.length == 0) {
            revert vaultArrayEmpty();
        }
        ///////////////////////REGISTER VAULT AND OPERATOR

        //GAS OPTIMIZATION
        address[] memory vaultArray = vaults;

        for (uint i = 0; i < vaultArray.length; i++) {
            /////////////SANITY CHECK

            uint interestRateOfEachVault = VaultRegularBorrowable(vaultArray[i])
                .getInterestRate(); //getInterestRate is an external function in any VaultRegularBorrowable instances
            if (interestRateOfEachVault == 0) {
                revert not_Compatible_WithVaultRegularBorrowable();
            }
            Manager[operator][msg.sender].push(vaultArray[i]);
        }
        evc.setAccountOperator(msg.sender, operator, true);
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastBlockTimeStamp) > rebalanceTimer;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        if ((block.timestamp - lastBlockTimeStamp) > rebalanceTimer) {
            lastBlockTimeStamp = block.timestamp;
            rebalance(Owner);
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function rebalance() internal onlyOwner returns (bool) {
        //msg.sender must be a registered operator in the PositionManager contract

        //CHECKSSSS
        if (Manager[msg.sender][Owner].length <= 0) {
            revert not_Registered();
        }
        if ((block.timestamp - lastBlockTimeStamp) > rebalanceTimer) {
            revert not_theTime();
        }

        address[] memory vaultManager = Manager[msg.sender][Owner];
        uint HighestVaulRate = 0;
        uint index;
        for (uint i = 0; i < vaultManager.length; i++) {
            uint HighestVaulRate = uint(
                VaultRegularBorrowable(vaultManager[i]).getInterestRate()
            );

            if (interestRate > highestRate) {
                highestRate = interestRate;
                index = i;
            }
        }

        address highestRateVault = vaultManager[i];
        for (uint i = 0; i < vaultManager.length; i++) {
            if (operatorVault[i] != highestRateVault) {
                address vault = vaultManager[i];
                uint maxWithdw = VaultRegularBorrowable(vault).maxWithdraw(
                    Owner
                );

                /////CALL THROUGH EVC AS AN OPERATOR/////////////////////////
                VaultRegularBorrowable(vaultOthers).withdraw(
                    maxWithdw,
                    vaultWithHighest,
                    accountOwner
                );
            }
        }
        return true;
    }
}
